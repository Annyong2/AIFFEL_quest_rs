# -*- coding: utf-8 -*-
"""gdr_0008_24_v3_Table_colab.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11pmAKQs5ED8FYGPljNiLQHRNGBjE7DsL
"""

!pip uninstall datasets -y
!pip install datasets

!pip install evaluate

pip install tensorboard

import datasets
from datasets import load_dataset
from evaluate import load as load_metric

import transformers
from transformers import AutoModelForSequenceClassification, AutoTokenizer, TrainingArguments, Trainer, get_linear_schedule_with_warmup

import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.font_manager as fm

import os
import re
import warnings
warnings.filterwarnings("ignore", category=UserWarning, module='bs4')
warnings.filterwarnings("once", module='matplotlib.font_manager')  # WARNING 메시지를 한 번만 출력하도록 설정
from tqdm.notebook import tqdm
import tensorflow as tf
import numpy as np
import pandas as pd
import multiprocessing

# 방법 1: os 모듈 사용
cpu_count_os = os.cpu_count()
print(f"CPU 코어 수 (os): {cpu_count_os}")

# 방법 2: multiprocessing 모듈 사용
cpu_count_mp = multiprocessing.cpu_count()
print(f"CPU 코어 수 (multiprocessing): {cpu_count_mp}")


# 한글설정
get_ipython().run_line_magic('config', "InlineBackend.figure_format = 'retina'")

fontpath = '/usr/share/fonts/truetype/malgun/MalgunGothic.ttf'  # 변경된 한글 폰트 경로 # HERE
font = fm.FontProperties(fname=fontpath, size=9)
plt.rc('font', family='Malgun Gothic')  # 변경된 폰트 이름 # HERE
mpl.font_manager.findfont(font)

print("한글설정 완료!")

"""## STEP 1. NSMC 데이터 분석 및 Huggingface dataset 구성"""

## STEP 1. NSMC 데이터 분석 및 Huggingface dataset 구성
dataset = load_dataset("nsmc")

# 훈련 데이터와 테스트 데이터 확인
train_dataset = dataset["train"]
test_dataset = dataset["test"]

print(train_dataset[0])  # 첫 번째 훈련 데이터 예시 출력
print(test_dataset[0])   # 첫 번째 테스트 데이터 예시 출력
print('\n')
# 데이터 읽기 : Train DATASET 5줄만 확인
cols = train_dataset.column_names
print(cols)
print('\n')

for i in range(5):
    for col in cols:
        print(col, ":", train_dataset[col][i])
    print('\n')

# 데이터 길이 분포 확인
train_lengths = [len(text) for text in train_dataset['document']]
plt.hist(train_lengths, bins=30, color='blue', alpha=0.7)
plt.xlabel('Document Length')
plt.ylabel('Frequency')
plt.title('Distribution of Document Lengths in Train Dataset')
plt.show()

"""## STEP 2. klue/bert-base model 및 tokenizer 불러오기"""

## STEP 2. klue/bert-base model 및 tokenizer 불러오기
# 모델, 토크나이저 불러오기
model = AutoModelForSequenceClassification.from_pretrained("klue/bert-base", num_labels=2)
tokenizer = AutoTokenizer.from_pretrained("klue/bert-base")

# 토큰화함수
def tokenize_function(dataframe):
    return tokenizer(
        dataframe['document'],
        padding='max_length',  # Pad sequences to the maximum length allowed by the model
        truncation=True,         # Truncate sequences that are too long
        max_length=128
    )

"""## STEP 3. 불러온 tokenizer으로 데이터셋 전처리 & model 학습 진행하기"""

## STEP 3. 불러온 tokenizer으로 데이터셋 전처리 & model 학습 진행하기
# 토큰화함수로 dataset 토큰화
tokenized_train_dataset = train_dataset.map(tokenize_function, batched=True, batch_size=16)
tokenized_test_dataset = test_dataset.map(tokenize_function, batched=True, batch_size=16)

# 가져오기 : accuracy metric
accuracy_metric = load_metric("accuracy")
def compute_metrics(eval_pred):
    predictions,labels = eval_pred
    predictions = np.argmax(predictions, axis=-1)  # 가장 높은 예측값의 label index을 선택
    return accuracy_metric.compute(predictions=predictions, references = labels)

"""## STEP 4. Fine-tuning을 통하여 모델 성능(accuarcy) 향상시키기

#### <조건 비교 : 시도 #01 -> **#02**>   
TrainingArguments Changes
- learning_rate = 2e-5 → **"3e-5"**   
- per_device_train_batch_size = 8 → **"16"**    
- per_device_eval_batch_size = 8 → **"16"**  
- num_train_epochs = 3 → "5"  

TrainingArguments Add  
*   logging_dir='./logs'
*   logging_steps=10
*   max_steps=int**(0.5 * 56250)**

⇒ 코랩에서 성능 좋은 GPU사용하여,   
전반적인 _**처리속도 개선** 효과뿐만 아니라_,  
**WandB(tool)* 사용**하여 fine-tuning 전후나 buketing 결과물을 대시보드로 한눈에 보고팠기에 옮김.  
(*그래서 logging_dir, logging_steps 추가함)  


---  

아무리 코랩이라도 **기존의 전체 학습은 무리가 되지 않을까**라는 기우에 다음과 같은 변화를 주었다.  


*   배치크기 늘리기 (학습처리 속도향상)
*   학습률 올리기 (학습처리 속도향상)
*   max_steps=int(0.5 * 56250) (학습량 줄이기)
"""

## STEP 4. Fine-tuning을 통하여 모델 성능(accuarcy) 향상시키기

# Adjust hyperparameters to enhance model performance
output_dir = os.getenv('HOME') + '/aiffel/transformers'
training_arguments = TrainingArguments(
    output_dir=output_dir,          # Save path
    evaluation_strategy="epoch",    # Evaluation frequency
    learning_rate=3e-5,             # Increased learning rate for potential improvement
    per_device_train_batch_size=16, # Increased batch size for better GPU utilization
    per_device_eval_batch_size=16,  # Increased evaluation batch size
    num_train_epochs=5,             # Increased number of epochs for more training
    weight_decay=0.01,              # Weight decay to prevent overfitting
    logging_dir='./logs',           # Directory for storing logs
    logging_steps=10,               # Log every 10 steps
    max_steps=int(0.5 * 56250),     # Train on 50% of the total steps # HERE
)

# Create a new Trainer instance with updated arguments
trainer_fine_tuned = Trainer(
    model=model,                      # Model to train
    args=training_arguments,           # Updated training arguments
    train_dataset=tokenized_train_dataset,  # Tokenized training dataset
    eval_dataset=tokenized_test_dataset,    # Tokenized evaluation dataset
    compute_metrics=compute_metrics,   # Metrics for evaluation
)

# Fine-tune the model
print("Fine-tuning the model...")
trainer_fine_tuned.train()
# Evaluate the fine-tuned model
print("Evaluating the fine-tuned model...")
evaluation_results = trainer_fine_tuned.evaluate()
print(f"Evaluation results: {evaluation_results}")

"""=>
_**"어..? 아니... 퍼실님이 90% 넘기 어려울 거라하셨는데...??!? "**_   

=> 목표 추가 -> **Accuracy 93% 이상** 달성해보자! (STEP 5. 완수 후 진행 할 것)

## STEP 5. Bucketing을 적용하여 학습시키고, STEP 4의 결과와의 비교

#### Bucketing을 적용하여 학습 & 평가하기
"""

# Import DataCollatorWithPadding for dynamic padding
from transformers import DataCollatorWithPadding

# Use DataCollatorWithPadding to dynamically pad the batches
# This ensures each batch is padded to the maximum sequence length within that batch, reducing padding overhead
collator = DataCollatorWithPadding(tokenizer=tokenizer)

# Update TrainingArguments to use bucketing by setting group_by_length=True
training_arguments_bucketing = TrainingArguments(
    output_dir=output_dir,  # Save path
    evaluation_strategy="epoch",  # Evaluation frequency
    learning_rate=3e-5,  # Learning rate
    per_device_train_batch_size=16,  # Training batch size per device
    per_device_eval_batch_size=16,  # Evaluation batch size per device
    num_train_epochs=5,  # Number of training epochs
    weight_decay=0.01,  # Weight decay
    group_by_length=True,  # Enable bucketing to group sequences of similar lengths
    logging_dir='./logs',  # Directory for storing logs
    logging_steps=10,  # Log every 10 steps
    max_steps=int(0.5 * 56250),  # Train on 50% of the total steps # HERE
)

# Create a Trainer instance with bucketing and dynamic padding
trainer_bucketing = Trainer(
    model=model,                      # Model to train
    args=training_arguments_bucketing, # Training arguments with bucketing
    train_dataset=tokenized_train_dataset,  # Tokenized training dataset
    eval_dataset=tokenized_test_dataset,    # Tokenized evaluation dataset
    compute_metrics=compute_metrics,   # Metrics for evaluation
    data_collator=collator,            # Data collator for dynamic padding
)

# Train the model with bucketing and dynamic padding
print("Training the model with bucketing and dynamic padding...")
trainer_bucketing.train()

# Evaluate the model trained with bucketing
print("Evaluating the model trained with bucketing...")
evaluation_results_bucketing = trainer_bucketing.evaluate()
print(f"Evaluation results with bucketing: {evaluation_results_bucketing}")

"""⇒ **빠르다!**

![image.png](data:image/png;base64,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)
"""

!zip -r logs.zip ./logs
from google.colab import files
files.download("logs.zip")

"""#### 결과비교 :  STEP 4 vs. STEP 5

TensorBoard로 보려했으나 깔끔하지 않아서 탈락
"""

# %load_ext tensorboard
# %tensorboard --logdir ./logs

print(evaluation_results)
print(evaluation_results_bucketing)

"""테이블로 결과 비교해보기로 함"""

data_eval = {
    "Metric" : list(evaluation_results.keys()),
    "Fine-tuned Mdl" : list(evaluation_results.values()),
    "Busketing Mdl" : list(evaluation_results_bucketing.values())
}

# DataFrame 생성 및 스타일 적용
comparison_df = pd.DataFrame(data_eval)
comparison_df_styled = comparison_df.style.set_table_styles(
    [{'selector': 'table', 'props': [('border', '2px solid black')]},
     {'selector': 'th', 'props': [('background-color', '#f2f2f2'), ('border', '1px solid black')]},
     {'selector': 'td', 'props': [('border', '1px solid black')]}]
).set_properties(**{
    'text-align': 'center'
})

# 테이블 출력
from IPython.display import display
print("Comparison of Fine-tuned Model and Bucketing Model:")
display(comparison_df_styled)

